//Generated by the 'MsvMemoryDumpAnalyser'
package com.github.gumtreediff.gen.antlr4.msv;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.tinkerpop.gremlin.structure.T;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.apache.tinkerpop.gremlin.structure.io.IoCore;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;
import org.junit.Test;

/** This class uses two Java property files on vertices and edges from
 * the MsvMemoryDumpAnalyser class to create a TinkerGraph and serialize the
 * Graph to GraphML for later input to some Graph Database. */
public class GraphMLCreation {

    private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger(GraphMLCreation.class.getName());
    private static Map<String, Vertex> vertices = null;

    // see http://tinkerpop.apache.org/docs/current/reference/#_the_graph_structure
    @Test
    public void creationTest() {

        try {

            TinkerGraph graph = TinkerGraph.open();

            vertices = new HashMap<String, Vertex>();
            Properties vertexProps = new Properties();
            vertexProps.load(new FileInputStream(MsvMemoryDumpAnalyser.OUTPUT_PATH + "vertex.properties"));

            //Vertex v11 = graph.addVertex(T.label, "ATTRIBUTE", "is", "grddl:transformation");
            Enumeration e = vertexProps.propertyNames();
            Vertex v = null;
            while (e.hasMoreElements()) {
                String key = (String) e.nextElement();
                String[] values = vertexProps.getProperty(key).split(",");
                if(values.length == 1 || values[1] == null || values[1].equals("null")){
                   v = graph.addVertex(T.label, values[0]);
                }else{
                   v = graph.addVertex(T.label, values[0], "is", values[1]);
                }
                vertices.put(key, v);
            }

            //v11.addEdge("hasChild", v12);
            Properties edgeProps = new Properties();
            edgeProps.load(new FileInputStream(MsvMemoryDumpAnalyser.OUTPUT_PATH + "edge.properties"));
            Vertex parentV = null;
            e = edgeProps.propertyNames();
            while (e.hasMoreElements()) {
                String key = (String) e.nextElement();
                String parentName = edgeProps.getProperty(key);
                if(parentName != null && !parentName.equals("null")){
                    parentV = vertices.get(parentName);
                    v = vertices.get(key);
                    v.addEdge("hasChild", parentV);
                }
            }

            final OutputStream os = new FileOutputStream("build" + File.separatorChar + "odf12-graph.xml");
            graph.io(IoCore.graphml()).writer().normalize(true).create().writeGraph(os, graph);
        } catch (FileNotFoundException ex) {
            Logger.getLogger(GraphMLCreation.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(GraphMLCreation.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}
